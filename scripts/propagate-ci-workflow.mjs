#!/usr/bin/env node
/* eslint-disable no-console */
import fs from 'node:fs/promises';
import path from 'node:path';

const fetchImpl = globalThis.fetch ?? (await import('node-fetch')).default;

const API_URL = 'https://api.github.com';
const DEFAULT_ORG = process.env.GITHUB_ORG || 'sovereign-codex';
const TOKEN = process.env.GITHUB_TOKEN;
const DEFAULT_TEMPLATE_PATH = path.resolve('.github/workflows/ci.yml');
const DEFAULT_BRANCH = 'automation/update-ci-workflow';
const DEFAULT_COMMIT_MESSAGE = 'chore: sync CI workflow template';
const DEFAULT_PR_TITLE = 'Sync CI workflow template';
const DEFAULT_PR_BODY = `This PR applies the latest shared CI workflow template from sovereign-codex/si-core.\n\nGenerated by running \`node scripts/propagate-ci-workflow.mjs\`.\n`;

function parseArgs() {
  const args = process.argv.slice(2);
  const options = {
    org: DEFAULT_ORG,
    template: DEFAULT_TEMPLATE_PATH,
    branch: DEFAULT_BRANCH,
    dryRun: false,
    repos: [],
    commitMessage: DEFAULT_COMMIT_MESSAGE,
    prTitle: DEFAULT_PR_TITLE,
    prBody: DEFAULT_PR_BODY,
    force: false,
  };

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    switch (arg) {
      case '--org':
        options.org = args[++i] ?? options.org;
        break;
      case '--template':
        options.template = path.resolve(args[++i] ?? options.template);
        break;
      case '--branch':
        options.branch = args[++i] ?? options.branch;
        break;
      case '--repo':
        options.repos.push(args[++i]);
        break;
      case '--commit-message':
        options.commitMessage = args[++i] ?? options.commitMessage;
        break;
      case '--pr-title':
        options.prTitle = args[++i] ?? options.prTitle;
        break;
      case '--pr-body':
        options.prBody = args[++i] ?? options.prBody;
        break;
      case '--force':
        options.force = true;
        break;
      case '--dry-run':
        options.dryRun = true;
        break;
      default:
        throw new Error(`Unknown argument: ${arg}`);
    }
  }

  return options;
}

function ensureToken() {
  if (!TOKEN) {
    throw new Error('GITHUB_TOKEN is required to propagate workflow templates.');
  }
}

function joinPathSegments(...segments) {
  return segments
    .flatMap((segment) => segment.split('/'))
    .map((segment) => encodeURIComponent(segment))
    .join('/');
}

async function githubRequest(method, path, { body, searchParams, headers = {}, allow404 = false } = {}) {
  const url = new URL(path, API_URL);
  if (searchParams) {
    for (const [key, value] of Object.entries(searchParams)) {
      if (value !== undefined && value !== null) {
        url.searchParams.set(key, value);
      }
    }
  }

  const response = await fetchImpl(url, {
    method,
    headers: {
      'User-Agent': 'codex-ci-propagation-script',
      Accept: 'application/vnd.github+json',
      Authorization: `Bearer ${TOKEN}`,
      ...headers,
    },
    body: body ? JSON.stringify(body) : undefined,
  });

  if (allow404 && response.status === 404) {
    return null;
  }

  if (!response.ok) {
    const text = await response.text();
    throw new Error(`${method} ${url.pathname} failed with ${response.status}: ${text}`);
  }

  if (response.status === 204) {
    return null;
  }

  return response.json();
}

async function fetchAllRepos(org) {
  const repos = [];
  let page = 1;
  const perPage = 100;

  while (true) {
    const data = await githubRequest('GET', `/orgs/${org}/repos`, {
      searchParams: {
        per_page: perPage,
        page,
        type: 'all',
      },
    });

    repos.push(...data);

    if (data.length < perPage) {
      break;
    }

    page += 1;
  }

  return repos;
}

function normaliseContent(content) {
  return content.replace(/\r\n/g, '\n');
}

function encodeContent(content) {
  return Buffer.from(content, 'utf8').toString('base64');
}

function decodeContent(content, encoding) {
  return Buffer.from(content, encoding).toString('utf8');
}

async function getWorkflowFile(owner, repo, ref) {
  const pathSegments = joinPathSegments('.github', 'workflows', 'ci.yml');
  const data = await githubRequest('GET', `/repos/${owner}/${repo}/contents/${pathSegments}`, {
    searchParams: { ref },
    allow404: true,
  });

  if (!data) {
    return null;
  }

  return {
    sha: data.sha,
    content: decodeContent(data.content, data.encoding),
  };
}

async function getRef(owner, repo, ref, { allow404 = false } = {}) {
  return githubRequest('GET', `/repos/${owner}/${repo}/git/ref/${joinPathSegments('heads', ref)}`, {
    allow404,
  });
}

async function createRef(owner, repo, ref, sha) {
  return githubRequest('POST', `/repos/${owner}/${repo}/git/refs`, {
    body: {
      ref: `refs/heads/${ref}`,
      sha,
    },
  });
}

async function updateFile(owner, repo, options) {
  const pathSegments = joinPathSegments('.github', 'workflows', 'ci.yml');
  return githubRequest('PUT', `/repos/${owner}/${repo}/contents/${pathSegments}`, {
    body: {
      message: options.commitMessage,
      content: encodeContent(options.templateContent),
      branch: options.branch,
      sha: options.sha,
    },
  });
}

async function ensurePullRequest(owner, repo, branch, base, title, body, dryRun) {
  const head = `${owner}:${branch}`;
  const existing = await githubRequest('GET', `/repos/${owner}/${repo}/pulls`, {
    searchParams: {
      state: 'open',
      head,
      per_page: 1,
    },
  });

  if (existing.length > 0) {
    const pr = existing[0];
    console.log(`  PR already open: ${pr.html_url}`);
    return pr;
  }

  if (dryRun) {
    console.log('  [dry-run] Would create pull request');
    return null;
  }

  const pr = await githubRequest('POST', `/repos/${owner}/${repo}/pulls`, {
    body: {
      title,
      head: branch,
      base,
      body,
    },
  });

  console.log(`  Created PR: ${pr.html_url}`);
  return pr;
}

async function ensureBranch(owner, repo, branch, baseRef, dryRun) {
  const existing = await getRef(owner, repo, branch, { allow404: true });
  if (existing) {
    return existing.object.sha;
  }

  if (dryRun) {
    console.log(`  [dry-run] Would create branch ${branch}`);
    return null;
  }

  const base = await getRef(owner, repo, baseRef);
  const baseSha = base.object.sha;
  await createRef(owner, repo, branch, baseSha);
  console.log(`  Created branch ${branch}`);
  return baseSha;
}

async function propagateToRepo(repo, options) {
  const owner = repo.owner.login;
  const repoName = repo.name;

  if (repo.archived) {
    console.log(`Skipping ${repoName} (archived)`);
    return;
  }

  const baseRef = repo.default_branch;
  const targetBranch = options.branch;

  const defaultFile = await getWorkflowFile(owner, repoName, baseRef);
  const currentContent = defaultFile ? normaliseContent(defaultFile.content) : null;
  const templateContent = normaliseContent(options.templateContent);

  if (!options.force && currentContent && currentContent === templateContent) {
    console.log(`Skipping ${repoName} (already matches template)`);
    return;
  }

  console.log(`Updating ${repoName}...`);
  await ensureBranch(owner, repoName, targetBranch, baseRef, options.dryRun);

  const branchFile = await getWorkflowFile(owner, repoName, targetBranch);
  const branchSha = branchFile ? branchFile.sha : defaultFile?.sha;

  if (options.dryRun) {
    console.log('  [dry-run] Would update workflow file');
  } else {
    await updateFile(owner, repoName, {
      commitMessage: options.commitMessage,
      templateContent: templateContent,
      branch: targetBranch,
      sha: branchSha,
    });
    console.log('  Workflow file updated');
  }

  await ensurePullRequest(
    owner,
    repoName,
    targetBranch,
    baseRef,
    options.prTitle,
    options.prBody,
    options.dryRun,
  );
}

async function main() {
  const options = parseArgs();
  ensureToken();

  const templateContent = await fs.readFile(options.template, 'utf8');
  options.templateContent = templateContent;

  const repos = await fetchAllRepos(options.org);
  const repoFilters = options.repos
    .map((name) => name?.split('/')?.filter(Boolean)?.pop())
    .filter(Boolean);
  const targets = repoFilters.length
    ? repos.filter((repo) => repoFilters.includes(repo.name))
    : repos;

  if (targets.length === 0) {
    console.log('No repositories matched the provided filters.');
    return;
  }

  for (const repo of targets) {
    try {
      await propagateToRepo(repo, options);
    } catch (error) {
      console.error(`Failed to update ${repo.name}: ${error.message}`);
    }
  }
}

main().catch((error) => {
  console.error(error.message);
  process.exitCode = 1;
});
